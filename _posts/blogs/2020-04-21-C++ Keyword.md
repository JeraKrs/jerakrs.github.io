---
layout: post
title: C++ 中一些关键词的用法
description: 总结了一些 C++ 中关键词的用法和注意事项，关键词包括 const、mutable、static、extern、inline。
category: C++
---

## const 关键词

const 可以指定一个语义约束，指定一个不该被改动的对象，而编译器会强制实施这项约束。const 常用于修饰变量、指针、变量引用、成员函数等，可以起到一定的约束作用。对于一个类的 const 对象、指针、引用，只能调用类的 const 成员函数。 

### 修饰变量

const 修饰变量一般有两种，两种写法没有区别，都是表示变量的值不可变。

```c++
const TYPE value;
TYPE const value;
```

### 修饰指针

而用 const 关键词修饰一个指针的话，不同的写法会有不同情况：如果关键词 const 出现在星号左边，表示被指物是常量，此时指针的值可以修改，但是不可以通过指针取修改被指变量的值；如果出现在星号右边，表示指针自身是常量，此时指针的值是不能更改的，但是可以通过指针修改被指变量的值；如果出现在星号两边，表示被指物和指针都是常量，都是不能被修改的。

```c++
char greeting[] = "Hello";
char* p = greeting;                // non-const pointer, non-const data;
const char* p = greeting;          // non-const pointer, const data;
char* const p = greeting;          // const pointer, non-const data;
const char* const p = greeting;    // const pointer, const data;
```

可以简单理解成 const 修饰的为关键词右边的东西，例如：

- `const char** p` ：指向一个 pointer 的指针 p，pointer 是一个指向 const data 的指针，我们可以通过指针 p 修改 pointer 的值，也可以修改指针 p 的值，但是不能通过 p 或 pointer 修改 pointer 指向的对象；
- `const char* const * p` ：指向一个 const pointer 的指针 p，pointer 是一个指向 const data 的指针，我们不可以通过 p 修改 const pointer 的值和 const pointer 指向的对象的值，但是可以修改指针 p 的值；
- `const char* const * const p` ：指向一个 const pointer 的指针 p，pointer 是一个指向 const data 的指针，不可以通过指针 p 修改 const pointer 的值和 const pointer 指向的对象的值，也不可以修改指针 p 的值；

### 修饰成员函数

- `const T func()` 表示返回的为 const 类型；
- `T func() const` 表示函数不能修改其成员变量； 

我们知道，成员函数的第一参数为默认的 `this` 指针，如果在成员函数后加 const 关键词，则传入的 `this` 指针是一个 const 指针。成员函数如果是 const 意味着什么？这里有流行的概念：bitwise constness（又称 physical constness）和 logical constness。

**bitwise constness** 认为，成员函数只有在不更改对象中任何成员变量时，才可以说是 const。不过很多成员函数虽然不具备 const 性质，但是却能通过 bitwise 测试，例如：

```c++
class CTextBlock {
public:
    char& operator[](std::size_t position) const {
        return pText[position];
    }
private:
    char* pText;
};
```

**logical constness**  主张一个 const 成员函数可以修改它所处理的对象内的某些 bits，但只有在客户端侦测不出的情况下才可以。但有时候符合 logical constness 的 const 成员函数并不能通过编译器，这时需要用 mutable（可变性）释放掉 non-static 成员变量的 bitwise constness 约束。

```c++
class CTextBlock {
private:
    mutable std::size_t textLength;
};
```

### 修饰引用

真实程序中 const 对象大多用于函数的 passed by pointer-to-const 或者 passed by reference-to-const 传递结果，可以减少值拷贝。

## mutable 关键词

在 C++ 中，mutable 也是为了突破 const 的限制而设置的。被 mutable 修饰的变量，将永远处于可变的状态，即使在一个 const 函数中。

```c++
class CTextBlock {
public:
	CTextBlock() : count(0) {}

	void process() const {
		count = count + 1;
		printf("%d\n", count);
	}
private:
	mutable int count;
};
```

## static 关键词

static 关键词的用法可以分为两类：面向过程程序设计中的 static 和面向对象程序设计中的 static。

### 面向过程程序设计中的 static

**静态全局变量**：在全局变量前，加上关键词 static，该变量就被定义成为一个静态全局变量。静态变量在全局变量数据区分配内存，并且未经初始化静态全局变量会被程序自动初始化为0。

```C++
static int x; // x = 0
```

如果静态全局变量定义在源文件中，那么该变量的作用域仅限定在当前文件中；如果定义在头文件中，那么引入该头文件的文件均可访问该变量。

**静态局部变量**：在局部变量前，加上关键词 static，该变量就被定义成为一个静态局部变量。一般局部变量的存放在栈空间上，作用域仅在函数内，生命周期也是在函数的调用期间。而静态局部变量存放在全局变量数据区，虽然作用域也仅在函数内，但是生命周期为整个程序运行期间。

```c++
void func() {
	static int count = 0;
	printf("%d\n", count++);
}

int main () {
	func(); // output: 0
	func(); // output: 1
	func(); // output: 2
	return 0;
}
```

**static 修饰函数**：将函数的作用域限定在当前源文件中，使得其他文件无法使用该函数。

### 面向对象程序设计中的 static

**静态成员变量**：被 static 修饰的成员变量为静态成员变量，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。

```c++
class STextBlock {
public:
	static int count;
};

int STextBlock::count = 0; // 静态成员变量的初始化
```

静态成员变量有两种访问方式：通过类名访问 和 通过变量访问。

```
STextBlock::count = 10; // 通过类名访问
STextBlock x;
x.count = 10; // 通过变量访问
```

**静态成员函数**：在成员函数前加 static 关键词，静态成员函数可以通过类名直接访问静态成员变量。

## extern 关键词

extern 关键词可以用来修饰变量或者函数，表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义，可以理解成是对变量和函数的一个声明。

### extern 修饰一个 const 变量

extern 修饰一个 const 变量时比较特殊，通常有两种方法，一是在定义变量前加 extern 修饰，二是在头文件中进行变量声明，然后使用的源文件中引入该头文件。

```C++
// main.cpp
#include <stdio.h>
#include "define.h"

extern int var;
extern const int extern_const_var;
extern const char* const_char_point;

int main () {
    printf("var=%d\n", var);
    printf("const_var=%d\n", const_var);
    printf("extern_const_var=%d\n", extern_const_var);
    printf("const_char_point=%s\n", const_char_point);

    return 0;
}
// define.h
extern const int const_var;

// define.cpp
#include "define.h"

int var = 0;
const int const_var = 0;
extern const int extern_const_var = 0;
const char* const_char_point = "const_char_point";

// compile command: g++ main.cpp define.cpp
```

## inline 关键词

被 inline 关键词修饰的函数为内联函数，内联函数在内部工作时将对应的函数替换成执行的代码，以减少频繁调用函数对栈内存重复开辟所带来的消耗。内联函数内的代码必须简单，不能包含复杂的结构控制语句，例如 while、switch，并且不能是递归函数。另外类中的成员函数缺省是内联的；内联函数的定义最好是放在头文件中。

inline 只是对编译器的一个建议，最终函数是不是内联函数取决于编译器的判断。
