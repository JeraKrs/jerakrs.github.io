<!DOCTYPE html>
<html>
	<head>
		<!--
		* Author:         Jerakrs
		-->

		<meta charset="utf-8" />

		<title> C/C++ 面经 | JeraKrs.com</title>

		<meta name="author" content="JeraKrs" />
		<meta name="description" content="JeraKrs's Blog" />
		<meta name="renderer" content="webkit">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0"> <!-- 自适应分辨率 -->

		<link rel="stylesheet" href="/css/default.css" type="text/css" />
		<link rel="shortcut icon" href="/Images/favicon.jpg" type="image/x-icon" />  <!-- 设置图标 -->

		<html xmlns:wb="http://open.weibo.com/wb"> <!-- 微博分享 -->

		<script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>

		</head>

		<body>

			<div class="home-menu">
				<div class="home-menu-info">
					<a class="home-info" href="/">JeraKrs</a>
					<a class="home-follow" href="#" title="Contact Me">+</a>
				</div>

				<div class="home-contact">
					<a href="http://weibo.com/JeraKrs/" target="_blank"><img src="http://www.weibo.com/favicon.ico" alt="" width="22"/></a>
					<a href="https://www.douban.com/people/BearChild-/" target="_blank"><img src="http://www.douban.com/favicon.ico" alt="" width="22"/></a>
					<a href="https://github.com/JeraKrs" target="_blank"><img src="https://github.com/fluidicon.png" alt="" width="22"/></a>
				</div>
			</div>

			<link rel="stylesheet" href="/js/prettify/prettify.css" />

<style type="text/css">
	body { background:#e8e8e8; }
	@media screen and (max-width: 800px){
		body { background:#ffffff; }
	}
</style>

<div id="content">

	<div class="sidemenu">
		<iframe width="100%" height="75" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=75&fansRow=2&ptype=1&speed=0&skin=1&isTitle=0&noborder=0&isWeibo=0&isFans=0&uid=1948705855&verifier=46dde484&dpc=1"></iframe>
	</div>

	<div class="blog">
		<h1 class="blog-title"><a href="/note/2016/06/29/C-C++.html" title="C/C++ 面经">C/C++ 面经</a></h1>
		<p class="blog-date">2016-06-29</p>

		<h2>概念性知识</h2>

<h3>C与C++的区别</h3>

<ul>
<li>从编程思想上讲: <br>
C是典型的命令式编程，也就是作者精确的设计出程序的每一个过程，程序一步步的执行。
C++严格的讲并不是完全的面向对象编程，而是支持多重编程范式的语言。用C++来编写程序可以是命令式的，也可以是面对对象的，甚至可以是函数式编程。</li>
<li>从应用上讲: <br>
C一般应用于要求高效，资源有限，与硬件相关度较大贴近底层的环境。如操作系统，驱动程序和嵌入式系统的编写。
C++执行效率高，又具有良好的软件工程性。适用于大规模的应用软件，游戏引擎的开发。我们所使用的大部分应用软件和几乎所有的大型游戏都是用C++编写的。</li>
</ul>


<h3>C++的三大特性</h3>

<p>封装、继承和多态</p>

<h4>封装</h4>

<ul>
<li>公有（ public ）成员可以在类外访问</li>
<li>私有（ private ）成员只能被该类的成员函数访问　</li>
<li>保护（ protected ）成员只能被该类的成员函数或派生类的成员函数访问</li>
</ul>


<h4>继承</h4>

<p>优点：<br></p>

<ul>
<li>类继承是在编译时刻静态定义的，且可直接使用；</li>
<li>类继承可以较方便地改变父类的实现；</li>
</ul>


<p>缺点：<br></p>

<ul>
<li>因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现；</li>
<li>父类通常至少定义了子类的部分行为，父类的任何改变都可能影响子类的行为；
如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。</li>
</ul>


<h4>多态</h4>

<p>C++多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。（重写的话可以有两种，直接重写成员函数和重写虚函数，只有重写了虚函数的才能算作是体现了C++多态性）</p>

<pre><code class="C++">/* 重写成员函数和重写虚函数的对比 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

class Animal {
    public:
        void type () { printf("Animal\n"); }
        virtual void run () { printf("Animal Run\n"); }
};

class Dog: public Animal {
    public:
        void type () { printf("Dog\n"); }
        void run () { printf("Dog Run\n"); }
};

int main () {
    Animal* p = new Dog;
    p-&gt;type();
    p-&gt;run();
    delete p;
    return 0;
}
</code></pre>

<p><strong>多态的作用</strong> <br>
隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；接口重用；</p>

<p><strong>虚函数和纯虚函数</strong> <br>
纯虚函数在基类中是没有定义的，必须在子类中加以实现。</p>

<h3>构造/析构函数的调用次序</h3>

<ul>
<li>构造函数调用次序是先基类的构造后派生类的构造；</li>
<li>析构函数调用次序是先派生类的析构后基类的析构；</li>
</ul>


<pre><code class="C++">/* 构造、析构函数的调用次序 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;

class Animal {
    public:
        Animal () { printf("It's animal\n"); }
        ~Animal () { printf("Delete animal\n"); }
};

class Dog: public Animal {
    public:
        Dog () { printf("I'm a dog\n"); }
        ~Dog () { printf("Wang!\n"); }
};

int main () {
    Dog* p = new Dog;
    delete p;
    return 0;
}
</code></pre>

<h3>变量的引用</h3>

<p>引用就是某个目标变量的“别名”(alias),对应用的操作与对变量直接操作效果完全相同。引用本身不占存储单元；不能对声明一个数组的引用。</p>

<h4>引用和多态的关系</h4>

<p>引用是除指针外另一个可以产生多态效果的手段。这意味着,一个基类的引用可以指向 它的派生类实例。</p>

<pre><code>/* 通过引用实现多态 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;

class Animal {
    public:
        virtual void type () { printf("Animal\n"); }
};

class Dog: public Animal {
    public:
        void type () { printf("Dog\n"); }
};

int main () {
    Dog d;
    Animal&amp; p = d;
    p.type();
    return 0;
}
</code></pre>

<h3>变参函数的实现</h3>

<ul>
<li>VA_LIST 是在C语言中解决变参问题的一组宏，所在头文件：<code>#include &lt;stdarg.h&gt;</code>，用于获取不确定个数的参数</li>
<li>INTSIZEOF 宏,获取类型占用的空间长度，最小占用长度为int的整数倍</li>
<li>VA_START宏，获取可变参数列表的第一个参数的地址</li>
<li>VA_ARG宏，获取可变参数的当前参数，返回指定类型并将指针指向下一参数</li>
<li>VA_END宏，清空可变参数列表</li>
</ul>


<pre><code>/* 变参函数的示例 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdarg&gt;

int get_sum(int n, ...) {
    va_list p;
    va_start(p, n);

    int ret = 0;

    for (int i = 0; i &lt; n; i++) {
        ret += va_arg(p, int);
    }

    va_end(p);
    return ret;
}

int main () {
    printf("%d\n", get_sum(2, 1, 3));
    printf("%d\n", get_sum(4, 1, 1, 1, 2));
    return 0;
}
</code></pre>

<h3>动态空间的申请和释放</h3>

<h4>new, delete, malloc, free的区别</h4>

<pre><code class="C++">void* operator new(size_t unSize);
void operator delete(void * ptr);
void* malloc(size_t size);
void free(void *ptr);
</code></pre>

<p>malloc/free 是C/C++的标准库函数，new/delete是C++的运算符。它们均可用来申请和释放动态内存空间，只是对于非内部数据类型的对象而言，光用 maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数,对象在消亡之前要自动执行析构函数。由于 malloc/free 是库函数而不是运算符,不在编译器控制权限之内,不能够把执行构造函数和析 构函数的任务强加于 malloc/free。</p>

<pre><code>/* new, delete, malloc, free 的比较 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;

class Cat {
    public:
        Cat () { printf("I'm a cat\n"); }
        ~Cat () { printf("Miao!\n"); }
};

class Dog {
    public:
        Dog () { printf("I'm a dog\n"); }
        ~Dog () { printf("Wang!\n"); }
};

int main () {
    Cat* pc = (Cat*)malloc(sizeof(Cat));
    free(pc);

    Dog* pd = new Dog;
    delete pd;
    return 0;
}
</code></pre>

<h4>delete 和delete[]的区别</h4>

<p>delete与new配套，delete[]与new[]配套。当 delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用 operator delete 来释放内存。即对于简单的数据类型而言，delete和delete[]可以混用，但是对于自定义的复杂数据类型，delete和delete[]不能互用。</p>

<h3>结构与联合有和区别</h3>

<ul>
<li>结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了 一个被选中的成员(所有成员共用一块地址空间), 而结构的所有成员都存在(不同成员的 存放地址不同)。</li>
<li>对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结 构的不同成员赋值是互不影响的。</li>
</ul>


<h3>重载(overload)和重写(overried)</h3>

<ul>
<li>从定义上来说：
  <br>重载：是指允许存在多个同名函数，而这些函数的参数表不同(或许参数个数不同，或许参数类型不同，或许两者都不同)；
  <br>重写：是指子类重新定义父类虚函数的方法；</li>
<li>从实现原理上来说：
  <br>重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数;
  <br>重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的；</li>
</ul>


<h3>const和#define区别</h3>

<ul>
<li>const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被 const 修饰的东西都受到强制保护，可以预防意外的变动,能提高程序的健壮性。</li>
<li><code>#define</code>：对字符进行替换。</li>
</ul>


<p>const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。</p>

<h3>数组和指针的区别</h3>

<p>数组要么在静态存储区被创建(如全局数组)，要么在栈上被创建。指针可以随时指向任意类型的内存块。</p>

<ul>
<li>修改内容上的差别</li>
</ul>


<pre><code>char a[] = "hello";
a[0] = 'X';
char *p = "world"; // 注意 p 指向常量字符串
p[0] = 'X'; // 编译器不能发现该错误,运行时错误
</code></pre>

<ul>
<li>用运算符 sizeof 可以计算出数组的容量(字节数)。</li>
</ul>


<pre><code>char a[] = "hello world";
char *p = a;
cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节
cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4 字节
</code></pre>

<h3>游标和指针的区别</h3>

<p>游标和指针很像，功能很像指针，通过重载一元的<code>*</code>和<code>-&gt;</code>来从容器中间接地返回一个值；</p>

<h3>进程和线程的区别</h3>

<ul>
<li>地址空间：进程内的一个执行单元；进程至少有一个线程；它们共享进程的地址空间；而进程有自己独立的地址空间;</li>
<li>进程是资源分配和拥有的单位，同一个进程内的线程共享进程的资源；</li>
<li>线程是处理器调度的基本单位，但进程不是；</li>
</ul>


<h3>class 和 struct 的区别</h3>

<ul>
<li>默认继承权限。如果不明确指定，来自 class 的继承按照 private 继承处理，来自 struct 的继承按照 public 继承处理；</li>
<li>成员的默认访问权限。class 的成员默认是 private 权限，struct 默认是 public 权限；</li>
<li>class 中有个默认的 this 指针，struct 没有；</li>
</ul>


<h3>简答问题</h3>

<ul>
<li>C++是不是类型安全的？<br>
答：不是。两个不同类型的指针之间可以强制转换。</li>
<li>main 函数执行以前,还会执行什么代码？<br>
答：全局对象的构造函数会在 main 函数之前执行。</li>
<li>当一个类 A 中没有任何成员变量与成员函数,这时<code>sizeof(A)</code>的值是多少？<br>
答：如果不是零，请解释一下编译器为什么没有让它为零。举个反例，如果是零的话,声明一个 <code>class A[10]</code>对象数组，而每一个对象占用的空间是零，这时就没办法区分 <code>A[0]</code>，<code>A[1]</code>了。</li>
<li>如何打印出当前源文件的文件名以及源文件的当前行号？<br>
答：
<code>
cout &lt;&lt; _FILE_ ;
cout &lt;&lt; _LINE_ ;
</code>
<code>_FILE_</code>和<code>_LINE_</code>是系统预定义宏，这种宏并不是在某个文件中定义的，而是由编译器定义的。</li>
<li><code>ifndef/define/endif</code> 的作用？<br>
答：防止该头文件被重复引用。</li>
<li><code>#include&lt;file.h&gt;</code> 与 <code>#include "file.h"</code>的区别？<br>
答：前者是从 Standard Library 的路径寻找和引用 <code>file.h</code>，而后者是从当前工作路径搜寻并引用 <code>file.h</code>。</li>
<li>堆栈溢出一般是由什么原因导致的？<br>
答：没有回收垃圾资源和层次太深的递归调用。</li>
<li>对于一个频繁使用的短小函数,在 C 语言中应用什么实现，在 C++中应用什么实现?<br>
答：c用宏定义，c++用 inline。</li>
<li>关键字 const 是什么含意？<br>
答：只读。</li>
<li>什么是预编译？<br>
答：预编译又称为预处理，是做些代码文本的替换工作。处理<code>#</code>开头的指令，比如拷贝<code>#include</code>包含的文件代码，<code>#define</code>宏定义的替换，条件编译等，就是为编译做的预备工作的阶段，主要处理<code>#</code>开始的预编译指令，预编译指令指示了在程序正式编译前就由编译器进行的操作，可以放在程序中的任何位置。</li>
<li>C语言中结构化程序设计的三种基本控制结构？<br>
顺序结构、选择结构、循环结构。</li>
<li>函数重载是什么？<br>
答：参数的个数或类型不同；返回值类型不同不算函数重载；</li>
<li>算数符的优先级? <br>
答：赋值运算符 &lt; 逻辑运算符 &lt; 关系运算符 &lt; 算术运算符</li>
</ul>


<h2>多进程</h2>

<h3>多进程的实现</h3>

<p><strong>头文件</strong></p>

<pre><code>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
</code></pre>

<p><strong>pid_t - 进程ID - <code>typedef unsigned int pid_t</code></strong></p>

<p><strong>fork - 创建一个子进程 - <code>pid_t fork(void);</code></strong></p>

<ul>
<li>在父进程中，fork返回新创建子进程的进程ID</li>
<li>在子进程中，fork返回0</li>
<li>如果出现错误，fork返回一个负值</li>
</ul>


<p><strong>exit – 终止进程- <code>void exit(int status);</code></strong></p>

<ul>
<li>statut不为0表示异常退出。</li>
</ul>


<p><strong>getpid – 获取当前进程的PI - <code>pid_t getpid(void);</code></strong></p>

<p><strong>wait –将父进程挂起等待子进程终止 - <code>pid_t wait(int *status);</code></strong></p>

<ul>
<li>如果其所有子进程都在运行，则阻塞</li>
<li>如果一个子进程已经终止，正在得带的父进程获取到终止状态，则取得该子进程的终止状态立即返回</li>
<li>如果他没有任何子进程，则立即出错返回</li>
</ul>


<pre><code class="C++">/* wait 测试 */
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt; 
#include &lt;sys/wait.h&gt;  
#include &lt;unistd.h&gt; 
#include &lt;algorithm&gt;

using namespace std;

void func () {
    printf("This is new process %d!\n", getpid());
}

int main(int argc, char * argv[])  {  

    pid_t pid[2]; 

    for (int i = 0; i &lt; 2; i++) {
        pid[i] = fork();

        switch(pid[i]) {
            case -1:
                printf("Fork fail!\n");
                break;
            case 0:
                func();
                if (i)
                    while (true);
                return 0;
        }
    }
    wait(NULL);
    wait(NULL);

    return 0;  
}
</code></pre>

<p><strong>waitpid - 挂起父进程等待指定子进程结束 - <code>pit_t waitpid(pid_t pid,int *status,int options);</code></strong>
<br><em>参数pid：</em></p>

<ul>
<li>pid > 0 时，只等待进程ID等于pid的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，waitpid就会一直等下去</li>
<li>pid = -1 时，等待任何一个子进程退出，没有任何限制，此时waitpid和wait的作用一模一样</li>
<li>pid = 0 时，等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会对它做任何理睬</li>
<li>pid &lt; -1 时，等待一个指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值</li>
</ul>


<p><em>参数options:</em></p>

<ul>
<li>WNOHANG，即使没有子进程退出，它也会立即返回，不会像wait那样永远等下去</li>
<li>WUNTRACED，则子进程进入暂停则马上返回，但结束状态不予以理会</li>
<li>Linux中只支持WNOHANG和WUNTRACED两个选项，这是两个常数，可以用"|"运算符把它们连接起来使用</li>
<li>如果我们不想使用它们，也可以把options设为0</li>
</ul>


<h3>进程间通信</h3>

<h4>1. 无名管道</h4>

<p><strong>pipe -  创建一个管道 - <code>int pipe(int filedes[2]);</code></strong>
<br><em>返回值：</em>成功，返回0，否则返回-1。参数数组包含pipe使用的两个文件的描述符。单向流动，并且只能在有亲缘关系的进程间使用。fd[0]:读管道，fd[1]:写管道。</p>

<pre><code class="C++">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt; 
#include &lt;sys/wait.h&gt;  
#include &lt;unistd.h&gt; 
#include &lt;signal.h&gt;
#include &lt;algorithm&gt;

using namespace std;

int main(int argc, char * argv[])  {  

    int p[2];
    pid_t pid;

    if (pipe(p) &lt; 0) {
        printf("pipe fail!\n");
        return 0;
    }

    if ( (pid = fork()) &lt; 0) {
        printf("Fork fail!\n");
    } else if (pid) {
        close(p[1]);
        char* buf = new char[100];

        read(p[0], buf, 100);
        printf("%s\n", buf);

    } else {
        close(p[0]);

        write(p[1], "hello son!", 100);
    }

    wait(NULL);

    return 0;  
}
</code></pre>

<h4>2. 命名管道</h4>

<p><strong>mkfifo - 创建一个命名管道 - <code>int mkfifo (const char *path,mode_t mode);</code></strong>
<br>mkfifo()会根据参数来创建特殊的有名管道文件，该文件要求必须不存在。
<br><em>头文件：</em>sys/stat.h
<br><em>参数path：</em> 管道文件的路径
<br><em>参数mode：</em> 管道文件的权限
<br><em>返回值：</em> -1为创建失败，0为创建成功</p>

<p><strong>access - 判断文件权限 - <code>int access(const char *pathname, int mode);</code></strong>
<br><em>参数mode：</em></p>

<ul>
<li>00 - 只检查文件是否存在</li>
<li>02 - 写权限</li>
<li>04 - 读权限</li>
<li>06 - 读写权限</li>
</ul>


<p><em>返回值：</em> -1为失败，0为成功</p>

<p><strong> read - 读数据 - <code>extern size_t read (int fd, void *buf, size_t nbytes);</code></strong>
<br><strong> write - 写数据 - <code>extern size_t write (int fd, const void *buf, size_t n);</code></strong>
<br><em>头文件：</em> unistd.h
<br>如果希望打开管道写端，则需要另一个进程打开管道读端，整个程序才能正常进行；如果只打开有名管道的一端，则系统将暂时阻塞打开进程，直到有另一个进程打开该管道的另一端，当前进程才会继续执行。</p>

<pre><code>/* write */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;limits.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

#define FIFO_NAME "./myfifo"

int main(int argc,char *argv[]) {

    int ret;
    int pipe_fd;
    char buf[] = "Hello world!";
    printf("%d\n", F_OK);

    if(access(FIFO_NAME, F_OK) == -1) { // 判断文件是否存在
        ret = mkfifo(FIFO_NAME, 0766);
        if(ret!=0) {
            fprintf(stderr, "Could not creat fifo %s\n", FIFO_NAME);
            exit(1);
        }
    }

    printf("Process %d opening FIFO O_WRONLY\n",getpid());

    pipe_fd = open(FIFO_NAME, O_WRONLY);

    printf("the file`s descriptor is %d\n",pipe_fd);

    if(pipe_fd != -1) {
        ret = write(pipe_fd,buf,sizeof(buf));
        printf("write data is %s, %d bytes is writen\n", buf, ret);
        close(pipe_fd);
    }

    printf("Process %d finished\n",getpid());
    return 0;
}
</code></pre>

<pre><code>/* read */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;limits.h&gt;
#include &lt;sys/types.h&gt;

#define FIFO_NAME "./myfifo"

int main(int argc,char *argv[]) {
    int pipe_fd;
    int ret;
    char buf[4096];
    int bytes_read=0;

    memset(buf, 0,sizeof(buf));

    printf("Process %d opening FIFO O_RDONLY\n", getpid());

    pipe_fd = open(FIFO_NAME, O_RDONLY);

    printf("the file`s descriptor is %d\n", pipe_fd);
    if (pipe_fd != -1) {
        bytes_read = read(pipe_fd, buf, sizeof(buf));
        printf("the read data is %s\n", buf);
        close(pipe_fd);
    }
    printf("Process %d finished,%d bytes read\n",getpid(),bytes_read);

    return 0;
}
</code></pre>

<h4>3. 信号量（semaphore）</h4>

<ul>
<li>头文件：<code>#include&lt;sys/sem.h&gt;</code></li>
<li>ipcs –s 查看所有信号量信息</li>
<li>ipcrm -s semid 删除指定信号量</li>
</ul>


<p><strong>semget - 获取一个信号量 - <code>int  semget(key_t  key ,int  nsems, int semflg);</code></strong>
<br>创建一个新的信号量或获取一个已经存在的信号量的键值
<br><em>返回值：</em>成功返回信号量的标识码ID。失败返回-1；
<br><em>参数key：</em>  （整型值）</p>

<ul>
<li>键值是IPC_PRIVATE，该值通常为0，意思就是创建一个仅能被与该进程有亲属关系的进程使用</li>
<li>键值不是IPC_PRIVATE，可以指定键值；也可以一个ftok()函数来取得一个唯一的键值</li>
</ul>


<p><em>参数nsems：</em> 表示初始化信号量的个数
<br><em>参数semflg  ：</em> 信号量的创建方式或权限</p>

<ul>
<li>IPC_CREAT如果信号量不存在，则创建一个信号量，否则获取</li>
<li>IPC_EXCL只有信号量不存在的时候，新的信号量才建立，否则就产生错误</li>
</ul>


<p><strong>semctl - 信号量操作 - <code>int  semctl(int semid  ,int semnum,int cmd, ……);</code></strong>
<br>控制信号量的信息。
<br><em>返回值：</em> 成功返回0，失败返回-1
<br><em>参数semnum：</em>  操作信号在信号集中的编号
<br><em>参数cmd：</em>    命令，表示要进行的操作</p>

<ul>
<li>IPC_STAT读取一个信号量集的数据结构semid_ds，并将其存储在semun中的buf参数中</li>
<li>IPC_SET设置信号量集的数据结构semid_ds中的元素ipc_perm，其值取自semun中的buf参数</li>
<li>IPC_RMID将信号量集从内存中删除</li>
<li>GETALL用于读取信号量集中的所有信号量的值</li>
<li>GETNCNT返回正在等待资源的进程数目</li>
<li>GETPID返回最后一个执行semop操作的进程的PID</li>
<li>GETVAL返回信号量集中的一个单个的信号量的值</li>
<li>GETZCNT返回这在等待完全空闲的资源的进程数目</li>
<li>SETALL设置信号量集中的所有的信号量的值</li>
<li>SETVAL设置信号量集中的一个单独的信号量的值</li>
</ul>


<p><em>参数Semunion：</em> 第4个参数是可选的；semunion :是union semun的实例</p>

<pre><code class="C++">union semun {
    int val;
    struct semid_ds *buf;
    unsigned short *arrary;
};
</code></pre>

<p><strong>semop - 处理信号量 - <code>int semop(int semid, struct sembuf *sops, size_t nsops);</code></strong>
<br>用户改变信号量的值，也就是使用资源还是释放资源使用权。
<br><em>返回值：</em> 成功返回0，失败返回-1
<br><em>参数sops：</em> 是一个指向结构体数组的指针
<br><em>参数sem_num：</em> 操作信号在信号集中的编号，第一个信号的编号为0</p>

<pre><code class="C++">/* 执行程序 */
#include &lt;stdio.h&gt;
#include &lt;sys/sem.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

#define MYKEY 6666

semun sem_union;

static int semid = 0;
static int set_semvalue();
static void del_semvalue();
static int semaphore_p();
static int semaphore_v();

int main() {

    semid = semget(MYKEY, 1, IPC_CREAT|0666);//创建了一个权限为666的信号量

    if (!set_semvalue()) {
        fprintf(stderr, "Failed to initialize semaphore\n");
        exit(EXIT_FAILURE);
    }

    printf("semid=%d\n",semid);

    for (int i = 1; i &lt;= 10; i++) {
        if (semaphore_p())
            printf("process %d: put number %d\n", getpid(), i);
    }

    semctl(semid, 0, IPC_RMID, sem_union);
    return 0;
}

static int set_semvalue() {
    union semun sem_union;

    sem_union.val = 1;
    if(semctl(semid, 0, SETVAL, sem_union) == -1)
        return 0;
    return 1;
}

static int semaphore_p() {
    struct sembuf sem_b;
    sem_b.sem_num = 0;
    sem_b.sem_op = -1;
    sem_b.sem_flg = SEM_UNDO;

    if(semop(semid, &amp;sem_b, 1) == -1) {
        fprintf(stderr, "semaphore_p failed\n");
        return 0;
    }

    return 1;
}

static int semaphore_v() {
    struct sembuf sem_b;
    sem_b.sem_num = 0;
    sem_b.sem_op = 1;
    sem_b.sem_flg = SEM_UNDO;
    if(semop(semid, &amp;sem_b, 1) == -1) {
        fprintf(stderr, "semaphore_v failed\n");
        return 0;
    }
    return 1;
}
</code></pre>

<pre><code class="C++">/* control 每输入一次回车，执行程序输出一个数字 */
#include &lt;stdio.h&gt;
#include &lt;sys/sem.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;stdlib.h&gt;

#define MYKEY 6666

semun sem_union;

static int semid = 0;
static int set_semvalue();
static void del_semvalue();
static int semaphore_p();
static int semaphore_v();

int main() {

    semid = semget(MYKEY, 1, IPC_CREAT|0666);

    for (int i = 1; i &lt; 10; i++) {
        scanf("%*c");
        semaphore_v();
    }

    return 0;
}

static int set_semvalue() {
    union semun sem_union;

    sem_union.val = 1;
    if(semctl(semid, 0, SETVAL, sem_union) == -1)
        return 0;
    return 1;
}

static int semaphore_p() {
    struct sembuf sem_b;
    sem_b.sem_num = 0;
    sem_b.sem_op = -1;
    sem_b.sem_flg = SEM_UNDO;

    if(semop(semid, &amp;sem_b, 1) == -1) {
        fprintf(stderr, "semaphore_p failed\n");
        return 0;
    }

    return 1;
}

static int semaphore_v() {
    struct sembuf sem_b;
    sem_b.sem_num = 0;
    sem_b.sem_op = 1;//V()
    sem_b.sem_flg = SEM_UNDO;
    if(semop(semid, &amp;sem_b, 1) == -1) {
        fprintf(stderr, "semaphore_v failed\n");
        return 0;
    }
    return 1;
}

static void del_semvalue() {
    union semun sem_union;

    if(semctl(semid, 0, IPC_RMID, sem_union) == -1)
        fprintf(stderr, "Failed to delete semaphore\n");
}
</code></pre>

<h4>4. 信号</h4>

<p><em>头文件：</em> <code>#include &lt;signal.h&gt;</code></p>

<p><strong>signal - 处理指定的信号 - <code>void (*signal(int sig, void (*func)(int)))(int);</code></strong>
<br><em>参数sig：</em></p>

<ul>
<li>SIGALRM：由alarm函数设置的定时器产生</li>
<li>SIGINT：Ctrl+C，终止</li>
<li>SIGKILL：强制终止异常程序</li>
<li>SIGPIPE：向管道写数据时没有对应的读进程时产生的信号</li>
<li>SIGTERM：要求进程结束，默认信号</li>
<li>SIGUSR1, SIGUSR2：进程间通信时使用的信号</li>
</ul>


<p><em>参数func：</em> 是一个类型为void (*)(int)的函数指针，也可以是特殊值</p>

<ul>
<li>SIG_IGN：忽略信号</li>
<li>SIG_DEL：恢复信号的默认行为</li>
</ul>


<pre><code class="C++">/* 第一次按下终止命令（ctrl+c）时，进程并没有被终止，面是输出OUCH! - I got signal 2，因为SIGINT的默认行为被signal函数改变了，当进程接受到信号SIGINT时，它就去调用函数ouch去处理，注意ouch函数把信号SIGINT的处理方式改变成默认的方式，所以当你再按一次ctrl+c时，进程就像之前那样被终止了。*/
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

void accept(int sig) {
    printf("OUCH! - I got signal %d\n", sig);
    //恢复终端中断信号SIGINT的默认行为
    (void) signal(SIGINT, SIG_DFL);
}

int main() {

    (void) signal(SIGINT, accept);
    printf("Process %d\n", getpid());

    while (true) {
        printf("hello\n");
        sleep(1);
    }
    return 0;
}
</code></pre>

<p><strong>sigaction - 处理指定的信号 - <code>int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);</code></strong></p>

<pre><code>struct sigaction {
    void (*) (int) sa_handler;
    sigset_t sa_mask;
    int sa_flags;
};
</code></pre>

<p><em>参数sa_handler：</em> 处理函数指针，相当于signal函数的func参数
<br><em>参数sa_mask：</em>  指定一个信号集，在调用sa_handler所指向的信号处理函数之前，该信号集将被加入到进程的信号屏蔽字中
<br><em>参数sa_flags：</em> 信号处理修改器</p>

<ul>
<li>SA_NOCLDSTOP：子进程停止时不产生SIGCHLD信号</li>
<li>SA_RESETHAND：将对此信号的处理方式在信号处理函数的入口处重置为SIG_DFL</li>
<li>SA_RESTART：重启可中断的函数而不是给出EINTR错误</li>
<li>SA_NODEFER：捕捉到信号时不将它添加到信号屏蔽字中</li>
</ul>


<p><em>参数oact：</em> 如果不是空指针的话，就用它来保存原先对该信号的动作的位置，act则用于设置指定信号的动作</p>

<pre><code class="C++">#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;

void ouch(int sig) {
    printf("OUCH! - I got signal %d\n", sig);
}

int main() {

    struct sigaction act;
    act.sa_handler = ouch;
    //创建空的信号屏蔽字，即不屏蔽任何信息
    sigemptyset(&amp;act.sa_mask);
    //使sigaction函数重置为默认行为
    act.sa_flags = SA_RESETHAND;

    sigaction(SIGINT, &amp;act, 0);

    while (1) {
        printf("Hello World!\n");
        sleep(1);
    }
    return 0;
}
</code></pre>

<p><strong>kill - 传送信号给指定的进程 - <code>int kill(pid_t pid,int sig);</code></strong>
<br><em>参数pid：</em></p>

<ul>
<li>pid > 0 将信号传给进程识别码为 pid 的进程</li>
<li>pid = 0 将信号传给和目前进程相同进程组的所有进程</li>
<li>pid = -1 将信号广播传送给系统内所有的进程</li>
<li>pid &lt; 0 将信号传给进程组识别码为pid 绝对值的所有进程</li>
</ul>


<p><em>参数sig：</em></p>

<ul>
<li>SIGHUP - 终端断线</li>
<li>SIGINT - 中断（同 Ctrl + C）</li>
<li>SIGQUIT - 退出（同 Ctrl + \）</li>
<li>SIGTERM - 终止</li>
<li>SIGKILL - 强制终止</li>
<li>SIGCONT -  继续（与STOP相反， fg/bg命令）</li>
<li>SIGSTOP - 暂停（同 Ctrl + Z）</li>
</ul>


<p><em>返回值：</em></p>

<ul>
<li>返回值执行成功则返回 0，如果有错误则返回-1 （1、给定的信号无效errno = EINVAL；2、发送权限不够errno = EPERM；3、目标进程不存在errno = ESRCH )</li>
</ul>


<p><em>错误代码：</em></p>

<ul>
<li>EINVAL 参数 sig 不合法</li>
<li>ESRCH 参数 pid 所指定的进程或进程组不存在</li>
<li>EPERM 权限不够无法传送信号给指定进程</li>
</ul>


<p><strong>alarm - 定时发送信号 - <code>unsigned int alarm(unsigned int seconds);</code></strong></p>

<pre><code class="C++">#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;

static int alarm_fired = 0;

void ouch(int sig) {
    alarm_fired = 1;
}

int main() {
    signal(SIGALRM, ouch);

    alarm(2);
    //在没有接收到信号时，挂起进程
    pause();

    if (alarm_fired == 1)
        printf("Receive a signal %d\n", SIGALRM);
    exit(0);
}
</code></pre>

<h4>5. 消息队列</h4>

<ul>
<li>头文件：<code>#include &lt;sys/msg.h&gt;</code></li>
<li>icps -q 查看消息队列</li>
<li>icprm -q msqid 删除指定消息队列</li>
</ul>


<p><strong>msgget - 创建与访问一个消息队列 - <code>int msgget(key_t key, int msgflg);</code></strong>
<br><em>返回值：</em> 如果成功，msgget函数会返回一个正数作为队列标识符，如果失败则会返回-1
<br><em>参数key：</em></p>

<ul>
<li>IPC_PRIVATE创建一个私有队列</li>
<li>IPC_CREAT</li>
</ul>


<p><em>参数msgflg：</em> 由9个权限标记组</p>

<p><strong>msgsnd - 向队列传送消息 - <code>int msgsnd(int msqid, const void *msg_ptr, size_t msg_sz, int msgflg);</code></strong>
<br>消息结构由两种方式来限定。第一，他必须小于系统限制，第二，必须以long int开始，这在接收函数中会用作一个消息类型。当我们在使用消息时，最好是以如下形式来定义我们的消息结构：</p>

<pre><code class="C++">struct my_message {
    long int message_type;
    /* The data you wish to transfer */
}
</code></pre>

<p><em>参数msgid：</em> 消息队列标识符
<br><em>参数msg_ptr：</em> 是一个指向要发送消息的指针，这个消息必须以long int类型开始
<br><em>参数msg_sz：</em> 消息的大小，尺寸必须不包含long int消息类型
<br><em>参数msgflg：</em> 控制消息队列已满或是达到了队列消息的系统限制时如何处理</p>

<ul>
<li>IPC_NOWAIT 函数就会立即返回而不发送消息，并且返回值为-1</li>
<li>IPC_NOWAIT 发送进程就会被挂起，等待队列中有可用的空间</li>
</ul>


<p><em>返回值：</em> 如果成功，函数会返回0，如果失败，则会返回-1。如果调用成功，系统就会复杂一份消息数据并将其放入消息队列中</p>

<p><strong>msgrcv - 接受队列中的消息 - <code>int msgrcv(int msqid, void *msg_ptr, size_t msg_sz, long int msgtype, int msgflg);</code></strong></p>

<p><em>参数msqid：</em> 消息队列标记符
<br><em>参数msg_ptr：</em> 是一个指向将要接收消息的指针，这个消息必须以long int类型开始。
<br><em>参数msg_sz：</em> 消息的大小，尺寸必须不包含long int消息类型
<br><em>参数msgtype：</em> 是一个long int类型，允许一个接收优先级形式的实现</p>

<ul>
<li>msgtype = 0 队列中第一个可用的消息就会被接收</li>
<li>msgtype > 0 具有相同消息类型的第一个消息就会被接收</li>
<li>msgtype &lt; 0 第一个具有相同类型或是小于msgtype绝对值的消息就会被接收</li>
</ul>


<p><em>参数msgflg：</em> 控制当没有合适类型的消息正在等待被接收时如何处理
* IPC_NOWAIT 调用就会立即返回，而返回值为-1
* 消除 IPC_NOWAIT 进程就会被挂起，等待一个合适类型的消息到来。</p>

<p><em>返回值：</em> 如果成功，msgrcv会返回放入接收缓冲区中的字节数，消息会被拷贝到由msg_ptr所指向的用户分配缓冲区中，而数据就会由消息队列中删除。如果失败则会返回-1</p>

<p><strong>msgctl - 系统操作 - <code>int msgctl(int msqid, int command, struct msqid_ds *buf);</code></strong>
<br><em>参数msqid：</em> 消息队列标记符
<br><em>参数command：</em> 执行的指令</p>

<ul>
<li>IPC_STAT  设置msqid_ds结构中的数据来反射与消息队列相关联的值</li>
<li>IPC_SET  如果进程有权限这样做，这个命令会设置与msqid_ds数据结构中所提供的消息队列相关联的值</li>
<li>IPC_RMID  删除消息队列</li>
</ul>


<pre><code class="C++">struct msqid_ds {
    uid_t msg_perm.uid;
    uid_t msg_perm.gid
    mode_t msg_perm.mode;
}
</code></pre>

<p><em>返回值：</em> 如果成功则会返回0，如果失败则会返回-1。当进程正在msgsnd或是msgrcv函数中等待时如果消息队列被删除，发送或接收函数就会失败</p>

<pre><code class="C++">/* receive */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;

#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;

const int MAX_TEXT = 512;

struct my_msg {
    long int msg_type;
    char message[MAX_TEXT];
};

int main () {

    int msgid, running = 1;
    my_msg msg;
    long int msg_sz = 0;

    msgid = msgget((key_t)1234, 0666|IPC_CREAT);

    if (msgid == -1) {
        fprintf(stderr,"msgget failed with error: %d/n", errno);
        exit(EXIT_FAILURE);
    }

    while(running) {
        if(msgrcv(msgid, (void *)&amp;msg, BUFSIZ, msg_sz, 0) == -1) {
            fprintf(stderr, "msgrcv failed with errno: %d/n", errno);
            exit(EXIT_FAILURE);
        }

        printf("You wrote: %s\n", msg.message);
        if(strncmp(msg.message, "end", 3)==0) {
            running = 0;
        }
    }

    if(msgctl(msgid, IPC_RMID, 0)==-1) {
        fprintf(stderr, "msgctl(IPC_RMID) failed/n");
        exit(EXIT_FAILURE);
    }

    return 0;
}
</code></pre>

<pre><code class="C++">/* control */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;

const int MAX_TEXT = 512;

struct my_msg {
    long int msg_type;
    char message[MAX_TEXT];
};

int main() {
    int running = 1;
    struct my_msg msg;
    int msgid;
    char buffer[MAX_TEXT];

    msgid = msgget((key_t)1234, 0666|IPC_CREAT);

    if(msgid==-1) {
        fprintf(stderr,"msgget failed with errno: %d/n", errno);
        exit(EXIT_FAILURE);
    }

    while (running) {
        printf("Enter your text: ");

        gets(buffer);

        msg.msg_type = 1;
        strcpy(msg.message, buffer);

        if(msgsnd(msgid, (void *)&amp;msg, MAX_TEXT, 0) == -1) {
            fprintf(stderr, "msgsnd failed/n");
            exit(EXIT_FAILURE);
        }

        if(strncmp(buffer, "end", 3) == 0) {
            running = 0;
        }
    }

    return 0;
}
</code></pre>

<h4>6. 共享内存</h4>

<ul>
<li>头文件： <code>#include &lt;sys/shm.h&gt;</code></li>
<li>ipcs -m 查看共享内存</li>
<li>ipcrm -m shmid 删除共享内存</li>
</ul>


<p><strong>shmget - 创建共享内存段 - <code>int shmget(key_t key, size_t size, int shmflg);</code></strong>
<br><em>参数key：</em> 共享内存标识符
<br><em>参数size：</em> 共享内存容量
<br><em>参数shmflg：</em> 共享内存权限标志</p>

<p><strong>shmat - 连接共享内存段 - <code>void *shmat(int shm_id, const void *shm_addr, int shmflg);</code></strong>
<br><em>参数shm_id：</em> 共享内存标识。
<br><em>参数shm_addr：</em> 指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址
<br><em>参数shm_flg：</em> 是一组标志位，通常为0。
<br> <em>返回值：</em> 调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1</p>

<p><strong>shmdt - 分离共享内存 - <code>int shmdt(const void *shmaddr);</code></strong>
<br> <em>参数shmaddr：</em> shmat函数返回的地址指针
<br> <em>返回值：</em> 调用成功时返回0，失败时返回-1</p>

<p><strong>shmctl - 控制共享内存 - <code>int shmctl(int shm_id, int command, struct shmid_ds *buf);</code></strong>
<br> <em>参数shm_id：</em> 共享内存标识符
<br> <em>参数command：</em></p>

<ul>
<li>IPC_STAT：把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值。</li>
<li>IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值</li>
<li>IPC_RMID：删除共享内存段</li>
</ul>


<p><em>参数buf：</em> 是一个结构指针，它指向共享内存模式和访问权限的结构</p>

<pre><code class="C++">struct shmid_ds  {  
    uid_t shm_perm.uid;  
    uid_t shm_perm.gid;  
    mode_t shm_perm.mode;  
};  
</code></pre>

<pre><code class="C++">/* receive */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;

#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;

const int MAX_TEXT = 2048;

struct my_shm {
    int flag;
    char text[MAX_TEXT];
};

int main () {
    int running = 1;
    void *shm = NULL;
    struct my_shm *shared;
    int shmid;

    // 创建共享内存`
    shmid = shmget((key_t)1234, sizeof(struct my_shm), 0666|IPC_CREAT);

    if(shmid == -1) {
        fprintf(stderr, "shmget failed\n");
        exit(EXIT_FAILURE);
    }

    //将共享内存连接到当前进程的地址空间
    shm = shmat(shmid, 0, 0);
    if(shm == (void*)-1) {
        fprintf(stderr, "shmat failed\n");
        exit(EXIT_FAILURE);
    }

    printf("\nMemory attached at %X\n", shm);

    //设置共享内存
    shared = (struct my_shm*)shm;
    shared-&gt;flag = 0;
    while (running) { //读取共享内存中的数据

        //没有进程向共享内存定数据有数据可读取
        if(shared-&gt;flag != 0) {
            printf("You wrote: %s\n", shared-&gt;text);
            sleep(rand() % 3);

            //读取完数据，设置written使共享内存段可写
            shared-&gt;flag = 0;

            //输入了end，退出循环（程序）
            if(strncmp(shared-&gt;text, "end", 3) == 0)
                running = 0;
        } else//有其他进程在写数据，不能读取数据
            sleep(1);
    }

    //把共享内存从当前进程中分离
    if(shmdt(shm) == -1) {
        fprintf(stderr, "shmdt failed\n");
        exit(EXIT_FAILURE);
    }

    //删除共享内存
    if(shmctl(shmid, IPC_RMID, 0) == -1) {
        fprintf(stderr, "shmctl(IPC_RMID) failed\n");
        exit(EXIT_FAILURE);
    }
    return 0;
}
</code></pre>

<pre><code class="C++">/* control */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;

#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;

const int MAX_TEXT = 2048;

struct my_shm {
    int flag;
    char text[MAX_TEXT];
};

int main() {
    int running = 1;
    void *shm = NULL;
    struct my_shm *shared = NULL;
    char buffer[MAX_TEXT];
    int shmid;

    //创建共享内存
    shmid = shmget((key_t)1234, sizeof(struct my_shm), 0666|IPC_CREAT);
    if(shmid == -1) {
        fprintf(stderr, "shmget failed\n");
        exit(EXIT_FAILURE);
    }

    //将共享内存连接到当前进程的地址空间
    shm = shmat(shmid, (void*)0, 0);
    if(shm == (void*)-1) {
        fprintf(stderr, "shmat failed\n");
        exit(EXIT_FAILURE);
    }
    printf("Memory attached at %X\n", shm);

    //设置共享内存
    shared = (struct my_shm*)shm;

    while (running) { //向共享内存中写数据

        //数据还没有被读取，则等待数据被读取,不能向共享内存中写入文本
        while(shared-&gt;flag == 1) {
            sleep(1);
            printf("Waiting...\n");
        }
        //向共享内存中写入数据
        printf("Enter some text: ");

        gets(buffer);

        strncpy(shared-&gt;text, buffer, MAX_TEXT);

        //写完数据，设置written使共享内存段可读
        shared-&gt;flag = 1;
        //输入了end，退出循环（程序）
        if(strncmp(buffer, "end", 3) == 0)
            running = 0;
    }

    //把共享内存从当前进程中分离
    if(shmdt(shm) == -1) {
        fprintf(stderr, "shmdt failed\n");
        exit(EXIT_FAILURE);
    }
    sleep(2);
    return 0;
}
</code></pre>

<h4>进程互斥锁</h4>

<p>线程锁共享，通过设置线程锁的属性，与子进程共享互斥锁。</p>


		<!-- 分享 -->
		<div id="share-button" style="float:right; line-height: 22px; height:22px;">
			<b>分享：</b>
			<wb:share-button addition="simple" type="icon" ralateUid="1948705855"></wb:share-button>
		</div>

		<!-- 评论 -->
		<div id="disqus_thread"></div>
		<script>
			(function() {  // DON'T EDIT BELOW THIS LINE
				var d = document, s = d.createElement('script');

				s.src = '//jerakrs.disqus.com/embed.js';

				s.setAttribute('data-timestamp', +new Date());
				(d.head || d.body).appendChild(s);
			})();
		</script>
		<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

	</div>

	<a id="gotop" href="#">
		<span>▲</span>
	</a>
</div>

<script src="/js/post.js" type="text/javascript"></script>
<script src="http://qzonestyle.gtimg.cn/qzone/app/qzlike/qzopensl.js#jsdate=20111201" charset="utf-8"></script>
<script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>

<script type="text/javascript">
	(function(){
		var p = {
			url:location.href,
			showcount:'1',/*是否显示分享总数,显示：'1'，不显示：'0' */
			desc:'',/*默认分享理由(可选)*/
			summary:'',/*分享摘要(可选)*/
			title:'',/*分享标题(可选)*/
			site:'JeraKrs.com',
			pics:'', /*分享图片的路径(可选)*/
			style:'203',
			width:22,
			height:22
		};
		var s = [];
		for(var i in p){
			s.push(i + '=' + encodeURIComponent(p[i]||''));
		}
		$('#share-button').append(['<a version="1.0" class="qzOpenerDiv" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?',s.join('&'),'" target="_blank" style="margin-top:10px">分享</a>'].join(''));
	})();
</script>


			<script type="text/javascript">
				$(function(){
					$('.home-follow').click(function(e){
						e.preventDefault();
						$('.home-contact').fadeToggle("slow")
					});
				})
			</script>
	</body>
</html>
