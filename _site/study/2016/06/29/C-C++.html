<!DOCTYPE html>
<html>
	<head>
		<!--
		* Author:         Jerakrs
		-->

		<meta charset="utf-8" />

		<title> C/C++ 面经 | JeraKrs.com</title>

		<meta name="author" content="JeraKrs" />
		<meta name="description" content="JeraKrs's Blog" />
		<meta name="renderer" content="webkit">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0"> <!-- 自适应分辨率 -->

		<link rel="stylesheet" href="/css/default.css" type="text/css" />
		<link rel="shortcut icon" href="/Images/favicon.jpg" type="image/x-icon" />  <!-- 设置图标 -->

		<html xmlns:wb="http://open.weibo.com/wb"> <!-- 微博分享 -->

		<script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>

		</head>

		<body>

			<div class="home-menu">
				<div class="home-menu-info">
					<a class="home-info" href="/">JeraKrs</a>
					<a class="home-follow" href="#" title="Contact Me">+</a>
				</div>

				<div class="home-contact">
					<a href="http://weibo.com/JeraKrs/" target="_blank"><img src="http://www.weibo.com/favicon.ico" alt="" width="22"/></a>
					<a href="https://www.douban.com/people/BearChild-/" target="_blank"><img src="http://www.douban.com/favicon.ico" alt="" width="22"/></a>
					<a href="https://github.com/JeraKrs" target="_blank"><img src="https://github.com/fluidicon.png" alt="" width="22"/></a>
				</div>
			</div>

			<link rel="stylesheet" href="/js/prettify/prettify.css" />

<style type="text/css">
	body { background:#e8e8e8; }
	@media screen and (max-width: 800px){
		body { background:#ffffff; }
	}
</style>

<div id="content">

	<div class="sidemenu">
		<iframe width="100%" height="75" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=75&fansRow=2&ptype=1&speed=0&skin=1&isTitle=0&noborder=0&isWeibo=0&isFans=0&uid=1948705855&verifier=46dde484&dpc=1"></iframe>
	</div>

	<div class="blog">
		<h1 class="blog-title"><a href="/study/2016/06/29/C-C++.html" title="C/C++ 面经">C/C++ 面经</a></h1>
		<p class="blog-date">2016-06-29</p>

		<h2>概念性知识</h2>

<h3>C与C++的区别</h3>

<ul>
<li>从编程思想上讲: <br>
C是典型的命令式编程，也就是作者精确的设计出程序的每一个过程，程序一步步的执行。
C++严格的讲并不是完全的面向对象编程，而是支持多重编程范式的语言。用C++来编写程序可以是命令式的，也可以是面对对象的，甚至可以是函数式编程。</li>
<li>从应用上讲: <br>
C一般应用于要求高效，资源有限，与硬件相关度较大贴近底层的环境。如操作系统，驱动程序和嵌入式系统的编写。
C++执行效率高，又具有良好的软件工程性。适用于大规模的应用软件，游戏引擎的开发。我们所使用的大部分应用软件和几乎所有的大型游戏都是用C++编写的。</li>
</ul>


<h3>C++的三大特性</h3>

<p>封装、继承和多态</p>

<h4>封装</h4>

<ul>
<li>公有（ public ）成员可以在类外访问</li>
<li>私有（ private ）成员只能被该类的成员函数访问　</li>
<li>保护（ protected ）成员只能被该类的成员函数或派生类的成员函数访问</li>
</ul>


<h4>继承</h4>

<p>优点：<br></p>

<ul>
<li>类继承是在编译时刻静态定义的，且可直接使用；</li>
<li>类继承可以较方便地改变父类的实现；</li>
</ul>


<p>缺点：<br></p>

<ul>
<li>因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现；</li>
<li>父类通常至少定义了子类的部分行为，父类的任何改变都可能影响子类的行为；
如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。</li>
</ul>


<h4>多态</h4>

<p>C++多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。（重写的话可以有两种，直接重写成员函数和重写虚函数，只有重写了虚函数的才能算作是体现了C++多态性）</p>

<pre><code class="C++">/* 重写成员函数和重写虚函数的对比 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

class Animal {
    public:
        void type () { printf("Animal\n"); }
        virtual void run () { printf("Animal Run\n"); }
};

class Dog: public Animal {
    public:
        void type () { printf("Dog\n"); }
        void run () { printf("Dog Run\n"); }
};

int main () {
    Animal* p = new Dog;
    p-&gt;type();
    p-&gt;run();
    delete p;
    return 0;
}
</code></pre>

<p><strong>多态的作用</strong> <br>
隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；接口重用；</p>

<p><strong>虚函数和纯虚函数</strong> <br>
纯虚函数在基类中是没有定义的，必须在子类中加以实现。</p>

<h3>构造/析构函数的调用次序</h3>

<ul>
<li>构造函数调用次序是先基类的构造后派生类的构造；</li>
<li>析构函数调用次序是先派生类的析构后基类的析构；</li>
</ul>


<pre><code class="C++">/* 构造、析构函数的调用次序 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;

class Animal {
    public:
        Animal () { printf("It's animal\n"); }
        ~Animal () { printf("Delete animal\n"); }
};

class Dog: public Animal {
    public:
        Dog () { printf("I'm a dog\n"); }
        ~Dog () { printf("Wang!\n"); }
};

int main () {
    Dog* p = new Dog;
    delete p;
    return 0;
}
</code></pre>

<h3>变量的引用</h3>

<p>引用就是某个目标变量的“别名”(alias),对应用的操作与对变量直接操作效果完全相同。引用本身不占存储单元；不能对声明一个数组的引用。</p>

<h4>引用和多态的关系</h4>

<p>引用是除指针外另一个可以产生多态效果的手段。这意味着,一个基类的引用可以指向 它的派生类实例。</p>

<pre><code>/* 通过引用实现多态 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;

class Animal {
    public:
        virtual void type () { printf("Animal\n"); }
};

class Dog: public Animal {
    public:
        void type () { printf("Dog\n"); }
};

int main () {
    Dog d;
    Animal&amp; p = d;
    p.type();
    return 0;
}
</code></pre>

<h3>变参函数的实现</h3>

<ul>
<li>VA_LIST 是在C语言中解决变参问题的一组宏，所在头文件：<code>#include &lt;stdarg.h&gt;</code>，用于获取不确定个数的参数</li>
<li>INTSIZEOF 宏,获取类型占用的空间长度，最小占用长度为int的整数倍</li>
<li>VA_START宏，获取可变参数列表的第一个参数的地址</li>
<li>VA_ARG宏，获取可变参数的当前参数，返回指定类型并将指针指向下一参数</li>
<li>VA_END宏，清空可变参数列表</li>
</ul>


<pre><code>/* 变参函数的示例 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdarg&gt;

int get_sum(int n, ...) {
    va_list p;
    va_start(p, n);

    int ret = 0;

    for (int i = 0; i &lt; n; i++) {
        ret += va_arg(p, int);
    }

    va_end(p);
    return ret;
}

int main () {
    printf("%d\n", get_sum(2, 1, 3));
    printf("%d\n", get_sum(4, 1, 1, 1, 2));
    return 0;
}
</code></pre>

<h3>动态空间的申请和释放</h3>

<h4>new, delete, malloc, free的区别</h4>

<pre><code class="C++">void* operator new(size_t unSize);
void operator delete(void * ptr);
void* malloc(size_t size);
void free(void *ptr);
</code></pre>

<p>malloc/free 是C/C++的标准库函数，new/delete是C++的运算符。它们均可用来申请和释放动态内存空间，只是对于非内部数据类型的对象而言，光用 maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数,对象在消亡之前要自动执行析构函数。由于 malloc/free 是库函数而不是运算符,不在编译器控制权限之内,不能够把执行构造函数和析 构函数的任务强加于 malloc/free。</p>

<pre><code>/* new, delete, malloc, free 的比较 */
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;

class Cat {
    public:
        Cat () { printf("I'm a cat\n"); }
        ~Cat () { printf("Miao!\n"); }
};

class Dog {
    public:
        Dog () { printf("I'm a dog\n"); }
        ~Dog () { printf("Wang!\n"); }
};

int main () {
    Cat* pc = (Cat*)malloc(sizeof(Cat));
    free(pc);

    Dog* pd = new Dog;
    delete pd;
    return 0;
}
</code></pre>

<h4>delete 和delete[]的区别</h4>

<p>delete与new配套，delete[]与new[]配套。当 delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用 operator delete 来释放内存。即对于简单的数据类型而言，delete和delete[]可以混用，但是对于自定义的复杂数据类型，delete和delete[]不能互用。</p>

<h3>结构与联合有和区别</h3>

<ul>
<li>结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了 一个被选中的成员(所有成员共用一块地址空间), 而结构的所有成员都存在(不同成员的 存放地址不同)。</li>
<li>对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结 构的不同成员赋值是互不影响的。</li>
</ul>


<h3>重载(overload)和重写(overried)</h3>

<ul>
<li>从定义上来说：
  <br>重载：是指允许存在多个同名函数，而这些函数的参数表不同(或许参数个数不同，或许参数类型不同，或许两者都不同)；
  <br>重写：是指子类重新定义父类虚函数的方法；</li>
<li>从实现原理上来说：
  <br>重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数;
  <br>重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的；</li>
</ul>


<h3>const和#define区别</h3>

<ul>
<li>const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被 const 修饰的东西都受到强制保护，可以预防意外的变动,能提高程序的健壮性。</li>
<li><code>#define</code>：对字符进行替换。</li>
</ul>


<p>const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。</p>

<h3>数组和指针的区别</h3>

<p>数组要么在静态存储区被创建(如全局数组)，要么在栈上被创建。指针可以随时指向任意类型的内存块。</p>

<ul>
<li>修改内容上的差别</li>
</ul>


<pre><code>char a[] = "hello";
a[0] = 'X';
char *p = "world"; // 注意 p 指向常量字符串
p[0] = 'X'; // 编译器不能发现该错误,运行时错误
</code></pre>

<ul>
<li>用运算符 sizeof 可以计算出数组的容量(字节数)。</li>
</ul>


<pre><code>char a[] = "hello world";
char *p = a;
cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节
cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4 字节
</code></pre>

<h3>游标和指针的区别</h3>

<p>游标和指针很像，功能很像指针，通过重载一元的<code>*</code>和<code>-&gt;</code>来从容器中间接地返回一个值；</p>

<h3>进程和线程的区别</h3>

<ul>
<li>地址空间：进程内的一个执行单元；进程至少有一个线程；它们共享进程的地址空间；而进程有自己独立的地址空间;</li>
<li>进程是资源分配和拥有的单位，同一个进程内的线程共享进程的资源；</li>
<li>线程是处理器调度的基本单位，但进程不是；</li>
</ul>


<h3>class 和 struct 的区别</h3>

<ul>
<li>默认继承权限。如果不明确指定，来自 class 的继承按照 private 继承处理，来自 struct 的继承按照 public 继承处理；</li>
<li>成员的默认访问权限。class 的成员默认是 private 权限，struct 默认是 public 权限；</li>
<li>class 中有个默认的 this 指针，struct 没有；</li>
</ul>


<h3>简答问题</h3>

<ul>
<li>C++是不是类型安全的？<br>
答：不是。两个不同类型的指针之间可以强制转换。</li>
<li>main 函数执行以前,还会执行什么代码？<br>
答：全局对象的构造函数会在 main 函数之前执行。</li>
<li>当一个类 A 中没有任何成员变量与成员函数,这时<code>sizeof(A)</code>的值是多少？<br>
答：如果不是零，请解释一下编译器为什么没有让它为零。举个反例，如果是零的话,声明一个 <code>class A[10]</code>对象数组，而每一个对象占用的空间是零，这时就没办法区分 <code>A[0]</code>，<code>A[1]</code>了。</li>
<li>如何打印出当前源文件的文件名以及源文件的当前行号？<br>
答：
<code>
cout &lt;&lt; _FILE_ ;
cout &lt;&lt; _LINE_ ;
</code>
<code>_FILE_</code>和<code>_LINE_</code>是系统预定义宏，这种宏并不是在某个文件中定义的，而是由编译器定义的。</li>
<li><code>ifndef/define/endif</code> 的作用？<br>
答：防止该头文件被重复引用。</li>
<li><code>#include&lt;file.h&gt;</code> 与 <code>#include "file.h"</code>的区别？<br>
答：前者是从 Standard Library 的路径寻找和引用 <code>file.h</code>，而后者是从当前工作路径搜寻并引用 <code>file.h</code>。</li>
<li>堆栈溢出一般是由什么原因导致的？<br>
答：没有回收垃圾资源和层次太深的递归调用。</li>
<li>对于一个频繁使用的短小函数,在 C 语言中应用什么实现，在 C++中应用什么实现?<br>
答：c用宏定义，c++用 inline。</li>
<li>关键字 const 是什么含意？<br>
答：只读。</li>
<li>什么是预编译？<br>
答：预编译又称为预处理，是做些代码文本的替换工作。处理<code>#</code>开头的指令，比如拷贝<code>#include</code>包含的文件代码，<code>#define</code>宏定义的替换，条件编译等，就是为编译做的预备工作的阶段，主要处理<code>#</code>开始的预编译指令，预编译指令指示了在程序正式编译前就由编译器进行的操作，可以放在程序中的任何位置。</li>
<li>C语言中结构化程序设计的三种基本控制结构？<br>
顺序结构、选择结构、循环结构。</li>
<li>函数重载是什么？<br>
答：参数的个数或类型不同；返回值类型不同不算函数重载；</li>
<li>算数符的优先级? <br>
答：赋值运算符 &lt; 逻辑运算符 &lt; 关系运算符 &lt; 算术运算符</li>
</ul>


<h2>多进程</h2>

<h3>多进程的实现</h3>

<p><strong>头文件</strong></p>

<pre><code>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
</code></pre>

<p><strong>pid_t - 进程ID - <code>typedef unsigned int pid_t</code></strong></p>

<p><strong>fork - 创建一个子进程 - <code>pid_t fork(void);</code></strong></p>

<ul>
<li>在父进程中，fork返回新创建子进程的进程ID</li>
<li>在子进程中，fork返回0</li>
<li>如果出现错误，fork返回一个负值</li>
</ul>


<p><strong>exit – 终止进程- <code>void exit(int status);</code></strong></p>

<ul>
<li>statut不为0表示异常退出。</li>
</ul>


<p><strong>getpid – 获取当前进程的PI - <code>pid_t getpid(void);</code></strong></p>

<p><strong>wait –将父进程挂起等待子进程终止 - <code>pid_t wait(int *status);</code></strong></p>

<ul>
<li>如果其所有子进程都在运行，则阻塞</li>
<li>如果一个子进程已经终止，正在得带的父进程获取到终止状态，则取得该子进程的终止状态立即返回</li>
<li>如果他没有任何子进程，则立即出错返回</li>
</ul>


<pre><code class="C++">/* wait 测试 */
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt; 
#include &lt;sys/wait.h&gt;  
#include &lt;unistd.h&gt; 
#include &lt;algorithm&gt;

using namespace std;

void func () {
    printf("This is new process %d!\n", getpid());
}

int main(int argc, char * argv[])  {  

    pid_t pid[2]; 

    for (int i = 0; i &lt; 2; i++) {
        pid[i] = fork();

        switch(pid[i]) {
            case -1:
                printf("Fork fail!\n");
                break;
            case 0:
                func();
                if (i)
                    while (true);
                return 0;
        }
    }
    wait(NULL);
    wait(NULL);

    return 0;  
}
</code></pre>

<p><strong>waitpid - 挂起父进程等待指定子进程结束 - <code>pit_t waitpid(pid_t pid,int *status,int options);</code></strong>
<br><em>参数pid：</em></p>

<ul>
<li>pid > 0 时，只等待进程ID等于pid的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，waitpid就会一直等下去</li>
<li>pid = -1 时，等待任何一个子进程退出，没有任何限制，此时waitpid和wait的作用一模一样</li>
<li>pid = 0 时，等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会对它做任何理睬</li>
<li>pid &lt; -1 时，等待一个指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值</li>
</ul>


<p><em>参数options:</em></p>

<ul>
<li>WNOHANG，即使没有子进程退出，它也会立即返回，不会像wait那样永远等下去</li>
<li>WUNTRACED，则子进程进入暂停则马上返回，但结束状态不予以理会</li>
<li>Linux中只支持WNOHANG和WUNTRACED两个选项，这是两个常数，可以用"|"运算符把它们连接起来使用</li>
<li>如果我们不想使用它们，也可以把options设为0</li>
</ul>


<p><strong>kill - 传送信号给指定的进程 - <code>int kill(pid_t pid,int sig);</code></strong>
<br><em>参数pid：</em></p>

<ul>
<li>pid > 0 将信号传给进程识别码为 pid 的进程</li>
<li>pid = 0 将信号传给和目前进程相同进程组的所有进程</li>
<li>pid = -1 将信号广播传送给系统内所有的进程</li>
<li>pid &lt; 0 将信号传给进程组识别码为pid 绝对值的所有进程</li>
</ul>


<p><em>参数sig：</em></p>

<ul>
<li>SIGHUP - 终端断线</li>
<li>SIGINT - 中断（同 Ctrl + C）</li>
<li>SIGQUIT - 退出（同 Ctrl + \）</li>
<li>SIGTERM - 终止</li>
<li>SIGKILL - 强制终止</li>
<li>SIGCONT -  继续（与STOP相反， fg/bg命令）</li>
<li>SIGSTOP - 暂停（同 Ctrl + Z）</li>
</ul>


<p><em>返回值：</em></p>

<ul>
<li>返回值执行成功则返回 0，如果有错误则返回-1。</li>
</ul>


<p><em>错误代码：</em></p>

<ul>
<li>EINVAL 参数 sig 不合法</li>
<li>ESRCH 参数 pid 所指定的进程或进程组不存在</li>
<li>EPERM 权限不够无法传送信号给指定进程</li>
</ul>


<h3>进程间通信</h3>

<h4>1. 无名管道</h4>

<p><strong>pipe -  创建一个管道 - <code>int pipe(int filedes[2]);</code></strong>
<br><em>返回值：</em>成功，返回0，否则返回-1。参数数组包含pipe使用的两个文件的描述符。单向流动，并且只能在有亲缘关系的进程间使用。fd[0]:读管道，fd[1]:写管道。</p>

<pre><code class="C++">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt; 
#include &lt;sys/wait.h&gt;  
#include &lt;unistd.h&gt; 
#include &lt;signal.h&gt;
#include &lt;algorithm&gt;

using namespace std;

int main(int argc, char * argv[])  {  

    int p[2];
    pid_t pid;

    if (pipe(p) &lt; 0) {
        printf("pipe fail!\n");
        return 0;
    }

    if ( (pid = fork()) &lt; 0) {
        printf("Fork fail!\n");
    } else if (pid) {
        close(p[1]);
        char* buf = new char[100];

        read(p[0], buf, 100);
        printf("%s\n", buf);

    } else {
        close(p[0]);

        write(p[1], "hello son!", 100);
    }

    wait(NULL);

    return 0;  
}
</code></pre>

<h4>2. 命名管道</h4>

<p><strong>mkfifo - 创建一个命名管道 - <code>int mkfifo (const char *path,mode_t mode);</code></strong>
<br>mkfifo()会根据参数来创建特殊的有名管道文件，该文件要求必须不存在。
<br><em>头文件：</em>sys/stat.h
<br><em>参数path：</em> 管道文件的路径
<br><em>参数mode：</em> 管道文件的权限
<br><em>返回值：</em> -1为创建失败，0为创建成功</p>

<p><strong>access - 判断文件权限 - <code>int access(const char *pathname, int mode);</code></strong>
<br><em>参数mode：</em></p>

<ul>
<li>00 - 只检查文件是否存在</li>
<li>02 - 写权限</li>
<li>04 - 读权限</li>
<li>06 - 读写权限</li>
</ul>


<p><em>返回值：</em> -1为失败，0为成功</p>

<p><strong> read - 读数据 - <code>extern size_t read (int fd, void *buf, size_t nbytes);</code></strong>
<br><strong> write - 写数据 - <code>extern size_t write (int fd, const void *buf, size_t n);</code></strong>
<br><em>头文件：</em> unistd.h
<br>如果希望打开管道写端，则需要另一个进程打开管道读端，整个程序才能正常进行；如果只打开有名管道的一端，则系统将暂时阻塞打开进程，直到有另一个进程打开该管道的另一端，当前进程才会继续执行。</p>

<pre><code>/* write */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;limits.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

#define FIFO_NAME "./myfifo"

int main(int argc,char *argv[]) {

    int ret;
    int pipe_fd;
    char buf[] = "Hello world!";
    printf("%d\n", F_OK);

    if(access(FIFO_NAME, F_OK) == -1) { // 判断文件是否存在
        ret = mkfifo(FIFO_NAME, 0766);
        if(ret!=0) {
            fprintf(stderr, "Could not creat fifo %s\n", FIFO_NAME);
            exit(1);
        }
    }

    printf("Process %d opening FIFO O_WRONLY\n",getpid());

    pipe_fd = open(FIFO_NAME, O_WRONLY);

    printf("the file`s descriptor is %d\n",pipe_fd);

    if(pipe_fd != -1) {
        ret = write(pipe_fd,buf,sizeof(buf));
        printf("write data is %s, %d bytes is writen\n", buf, ret);
        close(pipe_fd);
    }

    printf("Process %d finished\n",getpid());
    return 0;
}
</code></pre>

<pre><code>/* read */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;limits.h&gt;
#include &lt;sys/types.h&gt;

#define FIFO_NAME "./myfifo"

int main(int argc,char *argv[]) {
    int pipe_fd;
    int ret;
    char buf[4096];
    int bytes_read=0;

    memset(buf, 0,sizeof(buf));

    printf("Process %d opening FIFO O_RDONLY\n", getpid());

    pipe_fd = open(FIFO_NAME, O_RDONLY);

    printf("the file`s descriptor is %d\n", pipe_fd);
    if (pipe_fd != -1) {
        bytes_read = read(pipe_fd, buf, sizeof(buf));
        printf("the read data is %s\n", buf);
        close(pipe_fd);
    }
    printf("Process %d finished,%d bytes read\n",getpid(),bytes_read);

    return 0;
}
</code></pre>

<h4>共享内存</h4>

<p>共享内存也可以实现进程间的通信。进程需要可以被其他进程浏览的内存块。希望访问这个内存块的其他进程请求对它的访问，或由创建它的进程授予访问内存块的权限。可以访问特定内存块的所有进程对它具有即时可见性。共享内存被映射到使用它的每个进程的地址空间。所以，它看起来像是另一个在进程内声明的变量。当一个进程写共享内存，所有的进程都立即知道写入的内容，而且可以访问。</p>

<h4>进程互斥锁</h4>

<p>线程锁共享，通过设置线程锁的属性，与子进程共享互斥锁。</p>


		<!-- 分享 -->
		<div id="share-button" style="float:right; line-height: 22px; height:22px;">
			<b>分享：</b>
			<wb:share-button addition="simple" type="icon" ralateUid="1948705855"></wb:share-button>
		</div>

		<!-- 评论 -->
		<div id="disqus_thread"></div>
		<script>
			(function() {  // DON'T EDIT BELOW THIS LINE
				var d = document, s = d.createElement('script');

				s.src = '//jerakrs.disqus.com/embed.js';

				s.setAttribute('data-timestamp', +new Date());
				(d.head || d.body).appendChild(s);
			})();
		</script>
		<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

	</div>

	<a id="gotop" href="#">
		<span>▲</span>
	</a>
</div>

<script src="/js/post.js" type="text/javascript"></script>
<script src="http://qzonestyle.gtimg.cn/qzone/app/qzlike/qzopensl.js#jsdate=20111201" charset="utf-8"></script>
<script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>

<script type="text/javascript">
	(function(){
		var p = {
			url:location.href,
			showcount:'1',/*是否显示分享总数,显示：'1'，不显示：'0' */
			desc:'',/*默认分享理由(可选)*/
			summary:'',/*分享摘要(可选)*/
			title:'',/*分享标题(可选)*/
			site:'JeraKrs.com',
			pics:'', /*分享图片的路径(可选)*/
			style:'203',
			width:22,
			height:22
		};
		var s = [];
		for(var i in p){
			s.push(i + '=' + encodeURIComponent(p[i]||''));
		}
		$('#share-button').append(['<a version="1.0" class="qzOpenerDiv" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?',s.join('&'),'" target="_blank" style="margin-top:10px">分享</a>'].join(''));
	})();
</script>


			<script type="text/javascript">
				$(function(){
					$('.home-follow').click(function(e){
						e.preventDefault();
						$('.home-contact').fadeToggle("slow")
					});
				})
			</script>
	</body>
</html>
